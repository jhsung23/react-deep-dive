## 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 리액트 파이버(React Fiber)

### ✨ 리액트 파이버란?

- 리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체이다.
- 파이버 재조정자(fiber reconciler)가 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가진 파이버를 기준으로 화면에 렌더링을 요청한다.

> 재조정이란?(reconciler)
> <br/>리액트가 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

- 리액트 파이버는 웹 앱에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하기 위해 다음과 같은 일을 수행할 수 있다.

  - 작업을 작은 단위로 분할하고 쪼갠 뒤 **우선 순위를 매긴다.**
  - 이러한 작업은 일시 중지하고 나중에 다시 시작할 수 있다.
  - 이전에 했던 작업을 다시 재사용하거나 불필요하면 폐기도 할 수 있다.

  👉 이 모든 작업은 **비동기**로 이루어진다.
  <br/> 과거에는 이 조정 알고리즘이 '스택 알고리즘' 즉 하나의 스택에 렌더링에 필요한 작업을 쌓아 스택이 빌 때까지 **동기적**으로 작업을 수행하도록 되었었다. JS는 싱글스레드이기 때문에 이 작업은 중단될 수 없었고 이는 결국 비효율성으로 이어짐.

하지만 요즘 웹 앱에서는 사용자 인터렉션에 따른 동시 다발적 이벤트와 애니메이션과 같은 문제를 피할 수 없다.
<br/>👉 이러한 기존 렌더링 스택의 비효율성을 없애기 위해 스택 조정자 대신 **파이버**라는 개념이 탄생

### ✨ 파이버의 구성

파이버는 하나의 작업 단위로 구성되어 있다. 리액트는 이 작업 단위를 하나씩 처리한 뒤 `finishedWork()` 라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적 변경사항을 만들어 낸다. 이러한 단계는 아래 두 단계로 나눌 수 있다.

- 렌더 단계: 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행. 이 단계에서 앞서 언급한 파이버의 작업(우선순위 지정하거나 중지시키거나 버리는 등)이 일어난다.
- 커밋 단계: DOM에 실제 변경 사항을 반영하기 위한 작업인 commitWork()가 실행되는데 이 단계는 동기식으로 수행되고 중단될 수 없다.

리액트 요소와 가장 큰 차이점은, **"가급적이면 재사용한다"**. 컴포넌트가 최초 마운트 될 때 만들어지고, 이후에는 가급적 재사용된다.

```js
function FiberNode(tag, pendingProps, key, mode) {
  // ...
  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.refCleanup = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;
}
```

#### 🟡 tag

- 파이버는 하나의 element에 하나가 생성된다. 즉 element와 1:1 관계. 여기서 1:1로 매칭된 정보를 가지고 있는 것이 바로 tag. 1:1로 연결되는 것은 리액트의 컴포넌트일 수도, HTML의 DOM 노드일 수도, 혹은 다른 어떤 것일 수도 있다. (어떤 값이 가능한지는 0~25까지 리액트에 정의되어 있다)

#### 🟡 stateNode

- 파이버 자체에 대한 참조 정보를 가지고 있다. 이 참조를 바탕으로 리액트는 파이버와 관련된 상태에 접근한다.

#### 🟡 child, sibling, return

- 파이버 간의 관계 개념을 나타내는 속성. 리액트 컴포넌트 트리가 형성되는 것과 동일하게 파이버도 트리 형식을 가진다. 이 트리 형식을 구성하는 데 필요한 정보가 이 속성 내부에 정의된다.

- 리액트와 다른 점은 children이 없다는 점. 즉 하나의 child만 가질 수 있고, 여러 개의 자식이 있을 경우 첫번째 자식만 child이고 나머지는 그 첫번째 자식의 sibling으로 표현된다.

- return은 부모 파이버를 의미한다.

#### 🟡 index

- 여러 형제들 사이에서 자신의 위치가 몇 번째인지 숫자로 표현한다.

#### 🟡 pendingProps

- 아직 작업을 미처 처리하지 못한 props

#### 🟡 memoizedProps

- pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps로 저장해서 관리한다.

#### 🟡 updateQueue

- 상태 업데이트나 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐.

#### 🟡 memoizedState

- 함수형 컴포넌트의 훅 목록이 저장. useState뿐 아니라 모든 훅 리스트가 저장된다.

#### 🟡 alternate

- 리액트의 트리는 두 개인데, 그 중 반대편 트리를 가리킨다.

### ✨ 리액트 파이버 트리

파이버 트리는 리액트 내부에서 **두 개가 존재한다**!
<br/> 하나는 현재 모습을 담은 파이버 트리, 다른 하나는 작업 중인 상태를 나타내는 workInProgress 트리이다.
<br/> 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해서 workInProgress 트리를 현재 트리로 바꿔버린다.
<br/> 👉 이러한 기술을 더블 버퍼링이라고 한다. 이는 '커밋 단계' 에서 수행된다.

> 더블 버퍼링이란?
> <br/> 미처 다 그리지 못한 모습을 노출시키지 않기 위해(불완전한 트리를 보여주지 않기 위해) 보이지 않는 곳에서(가상) 다음 그려야 할 그림을 미리 그린 다음 완성되면 현재 상태를 새 그림으로 바꾸는 기법

1. 현재 UI 렌더링을 위해 존재하는 **current**를 기준으로 모든 작업이 시작된다.
2. 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 workInProgress 트리를 빌드하기 시작한다.
3. 해당 workInProgress 트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 current가 이 workInProgress로 변경된다.

### 파이버의 작업 순서

1. `beginWork()` 함수를 실행해서 파이브 작업 수행. 더 이상 자식이 없는 파이버를 만날 때 까지 트리 형식으로 시작된다.
2. 1번 작업이 끝나면 `completeWork()` 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2, 3번 작업이 모두 끝나면 return 으로 돌아가 자신의 작업이 완료됐음을 알린다.

```js
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1 />
      <D2 />
    </C1>
  </B2>
  <B3 />
</A1>
```

이렇게 트리가 생성되고 난 뒤 setState 등으로 업데이트가 발생하면 이미 리액트는 앞에서 만든 current 트리가 존재하고 setState로 인한 업데이트 요청을 받아 workInProgress 트리를 다시 빌드하기 시작! 이때는 이미 파이버가 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.
<br/> (즉 기존에 있는 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리 업데이트)
