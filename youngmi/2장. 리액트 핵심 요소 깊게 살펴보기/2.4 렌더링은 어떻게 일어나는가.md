## ✨ 렌더링은 어떻게 일어나는가?

브라우저에서의 렌더링이란 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정
<br/> 렌더링이 어떻게 이뤄지느냐에 따라 성능에도 큰 영향을 미친다.
<br/> 리액트에서의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 말한다. 리액트는 이 렌더링 과정을 위한 자체적인 렌더링 프로세스를 지닌다.

리액트의 렌더링은 시간과 리소스를 소비해 수행되기 때문에 이 비용은 모두 사용자에게 청구되며 시간이 길어지고 복잡해 질수록 UX를 저해하기 때문에, 개발자는 이 렌더링이 왜, 어떻게 어떤 순서로 일어나는지 알고 있어야 하며 이러한 렌더링 과정을 최소한으로 줄여야 한다.

### 🟡 리액트의 렌더링이란?

'렌더링'이라는 말은 브라우저에서도 쓰이기 때문에 혼동하면 안된다.

> 리액트에서의 렌더링
> <br/>리액트 애플리케이션 트리 안에 이는 모든 컴포넌트들이 현재 자신이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정.

### 🟡 리액트의 렌더링이 일어나는 이유

리액트 렌더링의 과정을 이해하는 것보다 중요한 것은 **'언제'** 렌더링이 발생하는가를 아는 것!
<br/>리액트에서 렌더링이 발생하는 시나리오는 다음과 같다.

1. 최초 렌더링
   <br/>사용자가 **처음 애플리케이션에 진입**하면 최초 렌더링 수행

2. 리렌더링
   <br/>최초 렌더링 이후 발생하는 모든 렌더링을 의미. 발생하는 경우는 아래와 같다

- 클래스형 컴포넌트의 `setState`가 실행되는 경우
  <br/> ➡ state의 변화는 곧 컴포넌트 상태의 변화를 의미. 클래스형 컴포넌트에서는 state의 변화를 setState 호출을 통해 수행하므로 리렌더링이 발생

- 클래스형 컴포넌트의 `forceUpdate`가 실행되는 경우
  <br/> ➡ 클래스형에서 렌더링을 수행하는 것은 인스턴스 메서드인 render 이다. 만약 이 render가 state나 props가 아닌 다른 값에 의존하고 있어 리렌더링을 자동으로 실행할 수 없을 경우 forceUpdate를 실행해 리렌더링을 일으킬 수 있다.
  <br/> 이때, 개발자가 강제로 렌더링이 필요하다고 선언한 것으로 간주해 shouldComponentUpdate는 무시.
  <br/> 한 가지 주의할 점은 render 내에서 forceUpdate가 사용되면 무한 루프에 빠진다.

- 함수형 컴포넌트의 useState()의 두번째 배열 요소인 setter가 실행되는 경우
  <br/> ➡ 이 배열은 클래스형 컴포넌트와 마찬가지로 state를 업데이트 하는 함수이다. 이 함수가 실행되면 렌더링 발생.

- 함수형 컴포넌트의 useReducer()의 두번째 배열 요소인 dispatch가 실행되는 경우
  <br/> ➡ useState와 마찬가지로 상태를 업데이트하는 함수를 배열로 제공.

- 컴포넌트의 key props가 변경되는 경우
  <br/> ➡ 리액트에서 key는 명시적으로 선언되어 있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props이다. 일반적으로는 배열에서 하위 컴포넌트를 선언할 때 사용.

  ```js
  export default function App() {
    return (
      <ul>
        {arr.map((index) => {
          <li key={index}>{index}</li>;
        })}
      </ul>
    );
  }
  ```

  - key를 안넣으면 경고가 뜬다. 왜 일까?
    <br/> ➡ 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. 리액트 파이버는 트리 구조에서 형제 컴포넌트를 구별하기 위해서 각자 sibling이라는 속성값을 사용함. 만약 동일한 자식 컴포넌트가 여러개 있으면 리렌더링 발생 시 current 트리와 workInProgress 트리 사이에서 어떤 컴포넌트가 변경되었는지 구별해야 하는데 이때 사용하는 것이 key. (없으면 단순히 파이버 내부의 sibling 인덱스만을 기준으로 판단한다.)

- props가 변경되는 경우
  <br/> ➡ 부모로부터 전달받는 값인 props가 달라지면 이를 사용하는 자식 컴포넌트에서도 변경이 필요하기 때문에 리렌더링이 발생한다.

- 부모 컴포넌트가 렌더링되는 경우
  <br/> ➡ 한가지 주의할 점은 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링이 발생한다는 점.

### 🟡 리액트의 렌더링 프로세스

리액트에서 렌더링이 어떤 과정을 거쳐 수행되는지 살펴보자.
<br/> ➡ 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서 차근차근 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
만약 여기서 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 클래스형 컴포넌트는 `render()` 함수를 실행하고 함수형 컴포넌트는 `FunctionComponent()` 그 자체를 호출한 뒤에 그 결과물을 저장한다.

이때 렌더링의 결과물은 JSX 문법으로 구성돼 있고 이것이 JS로 컴파일 되면서 `React.createElement()`를 호출하는 구문으로 변환된다.

```js
function Hello() {
  return (
    <TestComponent a={35} b={"yceffort"}>
      안녕하세요
    </TestComponent>
  );
}

// createElement 호출
function Hello() {
  return React.createElement(
    TestComponent,
    { a: 35, b: "yceffort" },
    "안녕하세요"
  );
}

// createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 JS 객체(결과물)를 반환한다.
{type: TestComponent, props:{a: 35, b: 'yceffort', children: '안녕하세요'}}
```

렌더링 프로세스가 실행되면서 위 과정들을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해서 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다. ➡ 재조정(Reconciliation)

재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보여진다.

### 🟡 렌더와 커밋

리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다.

#### 🔹 렌더단계(Render Phase)

컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업.
<br/> 즉, 컴포넌트를 실행(render, return)해서 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계.

여기서 비교하는 것은 크게 세 가지로, type, props, key 이다. 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.

#### 🔹 커밋단계(Commit Phase)

렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정. 이 단계가 끝나야 비로소 브라우저 렌더링이 발생한다.

리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다.
그 다음, 생명주기 개념이 있는 클래스형 컴포넌트에서는 componentDidMount, componenetDidUpdate 메서드를 호출하고, 함수형에서는 useLayoutEffect 훅을 호출한다.

> 잠깐, useLayoutEffect 훅이란?
> <br/>useEffect의 경우 DOM의 레이아웃 배치와 페인트가 끝난 후 이펙트 함수를 호출하기 때문에 상태값이 이펙트에 의존할 경우 약간 불편한 사용자 경험으로 이어질 수 있다. 이를 개선하기 위해 등장한 것이 useLayoutEffect이다. 레이아웃 이펙트는 브라우저가 화면에 DOM을 그리기 전에 이펙트를 수행한다. (https://merrily-code.tistory.com/46)

여기서 알 수 있는 중요한 사실은 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것! 렌더 단계를 수행하여 변경 사항을 계산했으나 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략이 가능하다. 커밋 단계가 생략되면 브라우저의 DOM 업데이트는 일어나지 않는다.

이 두 가지 과정으로 이뤄진 리액트 렌더링은 항상 동기식으로 작동했다. 따라서 렌더링 과정이 길어질수록 성능 저하로 이어지고 결과적으로 그 시간만큼 브라우저의 다른 작업을 지연시킬 가능성이 있다.

일반적으로 비동기 방식으로 렌더링이 이뤄지면 사용자는 하나의 상태에 대해 여러 다른 UI를 만나게 되므로 혼란을 일으킬 수 있다.
<br/> 하지만 B의 컴포넌트 렌더링 작업이 무거워 상대적으로 빠르게 렌더링할 수 있는 C라도 변경해서 보여줄 수 있다면? 이럴 때 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, '동시성 렌더링'이 쓰인다.
